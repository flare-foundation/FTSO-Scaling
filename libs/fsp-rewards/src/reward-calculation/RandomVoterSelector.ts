import { ethers } from "ethers";
import { Address } from "../../../ftso-core/src/voting-types";
import Web3 from "web3";
import { encodeParameters } from "web3-eth-abi";

const web3 = new Web3("https://dummy");
/**
 * Random voter selector for finalization reward eligibility calculation.
 */
export class RandomVoterSelector {
  thresholds: bigint[];
  totalWeight: bigint;
  votersSigningAddresses: Address[];
  weights: bigint[];
  defaultThresholdBIPS: number;

  constructor(votersSigningAddresses: Address[], weights: bigint[], defaultThresholdBIPS: number) {
    if (votersSigningAddresses.length !== weights.length) {
      throw new Error("voters and weights must have the same length");
    }
    this.votersSigningAddresses = [...votersSigningAddresses];
    this.weights = [...weights];
    this.totalWeight = 0n;
    this.thresholds = [];
    for (const weight of weights) {
      this.thresholds.push(this.totalWeight);
      this.totalWeight += weight;
    }
    this.defaultThresholdBIPS = defaultThresholdBIPS;

    // We limit the threshold to 5000 BIPS to avoid long running loops
    // In practice it will be used with around 1000 BIPS or lower.
    if (this.defaultThresholdBIPS <= 0 || this.defaultThresholdBIPS > 5000) {
      throw new Error("Default threshold must be between 0 and 10000 BIPS");
    }
  }

  /**
   * Selects a random voter signing address based provided random number.
   * Random number is encoded as 32-bytes 0x prefixed hex string.
   * @returns the selected voter
   */
  public selectVoterIndex(randomNumber: string): number {
    if (!randomNumber.startsWith("0x")) {
      throw new Error("Random number must be 0x-prefixed hex string");
    }
    const randomWeight = BigInt(randomNumber) % this.totalWeight;
    const index = this.binarySearch(randomWeight);
    return index;
  }

  /**
   * Searches for the highest index of the threshold that is less than or equal to the value.
   * Binary search is used.
   */
  public binarySearch(value: bigint): number {
    if (value < 0n || value > this.totalWeight) {
      throw new Error("Value must be between 0 and total weight");
    }
    let left = 0;
    let right = this.thresholds.length - 1;
    let mid = 0;
    if (this.thresholds[right] <= value) {
      return right;
    }
    while (left < right) {
      mid = Math.floor((left + right) / 2);
      if (this.thresholds[mid] < value) {
        left = mid + 1;
      } else if (this.thresholds[mid] > value) {
        right = mid;
      } else {
        return mid;
      }
    }
    return left - 1;
  }

  /**
   * Based on initial seed and threshold in BIPS it selects a random set of voters with weight
   * greater than or equal to the threshold. The threshold is expressed in BIPS (basis points)
   * of total voter weight.
   * If the threshold is 0 it randomly selects on voter, with probability proportional to its weight.
   */
  public randomSelectThresholdWeightVoters(randomSeed: string): Address[] {
    // We limit the threshold to 5000 BIPS to avoid long running loops
    // In practice it will be used with around 1000 BIPS or lower.
    let selectedWeight = 0n;
    const thresholdWeight = (this.totalWeight * BigInt(this.defaultThresholdBIPS)) / 10000n;
    let currentSeed = randomSeed;
    const selectedVoters = new Set<Address>();

    // If threshold weight is not too big, the loop should end quickly
    while (selectedWeight < thresholdWeight) {
      const index = this.selectVoterIndex(currentSeed);
      const selectedAddress = this.votersSigningAddresses[index].toLowerCase();
      if (!selectedVoters.has(selectedAddress)) {
        selectedVoters.add(selectedAddress);
        selectedWeight += this.weights[index];
      }
      currentSeed = ethers.keccak256(currentSeed);
    }
    return [...selectedVoters];
  }

  public randomNumberSequence(initialSeed: string, length: number): string[] {
    const sequence = [];
    let currentSeed = initialSeed;
    for (let i = 0; i < length; i++) {
      sequence.push(currentSeed);
      currentSeed = ethers.keccak256(currentSeed);
    }
    return sequence;
  }

  /**
   * Initial seed for random voter selection for finalization reward calculation.
   * Initial seed is calculated as a hash of protocol ID and voting round ID.
   * The seed is used for the first random. Next randoms are generated by
   */
  public static initialHashSeed(rewardEpochSeed: string, protocolId: number, votingRoundId: number): string {
    return Web3.utils.soliditySha3(
      encodeParameters(["bytes32", "uint256", "uint256"], [rewardEpochSeed, protocolId, votingRoundId])
    )!;
  }

  /**
   * Given protocol ID, voting round ID and address, it checks if the address is in the selection set.
   */
  public inSelectionList(
    voters: Address[],
    rewardEpochSeed: string,
    protocolId: number,
    votingRoundId: number,
    address: Address
  ): number {
    const initialSeed = RandomVoterSelector.initialHashSeed(rewardEpochSeed, protocolId, votingRoundId);
    const selection = this.randomSelectThresholdWeightVoters(initialSeed);
    const result = voters.filter(voter => selection.includes(voter));
    for (let i = 0; i < result.length; i++) {
      if (result[i].toLowerCase() === address.toLowerCase()) {
        return i;
      }
    }
    return -1;
  }
}
